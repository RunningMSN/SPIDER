import pandas as pd
from pyfaidx import Fasta
from helpers.crawler import reverse_complement
from Bio.Seq import Seq
import sys
import os

def extract_sequences(input_tsv, translate, output, separate, upstream, downstream):
	"""
	Extracts target sequences from a SPIDER search and outputs in FASTA format.

	Arguments:
		input_tsv -- tsv output generated by SPIDER
		translate -- True/false whether or not to translate the sequence from nucleotide to amino acid
		output -- Output file location. If none, output to console.
		upstream -- Amount of nucleotides upstream of amplicon to include.
		downstream -- Amount of nucleotides downstream of amplicon to include.

	Returns:
		True/False -- If extracted sequences (have valid sequences) return True. Otherwise return False.
	"""
	try:
		# Read SPIDER output file
		df_input = pd.read_csv(input_tsv, sep="\t")

		# Filter to valid inputs
		valid_inputs = df_input[df_input["Valid"]]

		if len(valid_inputs) > 0:
			# If separating output, create output folder
			if separate:
				os.makedirs(output, exist_ok=True)

			# Iterate through the sequence
			for index, row in valid_inputs.iterrows():
				# Store type of sequence output
				type = "NT"
				# Grab sequence. Assumes that file is where it was when entered into SPIDER.
				seq, start_position, end_position = get_sequence(row["Query"], row["Contig"], int(row["Start"]), int(row["End"]), row["Strand"], upstream, downstream)
				# Create header
				header = f'>{os.path.basename(row['Query'])}\t{row['Name']}\tcontig={row['Contig']};start={start_position};end={end_position}'
				# Translate if needed
				if translate:
					type = "AA"
					if not seq.lower().startswith("atg"):
						print(f"WARNING: The sequence for {row['Name']} in {row['Query']} does not start with ATG.", file=sys.stderr)
					seq = translate_seq(seq)
				# Wrap sequence for nicer output
				wrapped_seq = wrap_sequence(seq)
				# If no output, then send to stdout
				if not output:
					print(f"{header}\n{wrapped_seq}\n")
				# Send output to file
				else:
					# Grab proper output file
					if separate:
						output_file_name = f"{output}/{row['Name']}.fasta"
					else:
						output_file_name = output
					# Write output
					with open(output_file_name, "a") as write_file:
						write_file.write(f"{header}\n{wrapped_seq}\n")
			# If have valid sequences to extract return true
			return True
		else:
			print(f"ERROR: The file {input_tsv} did not contain any valid sequences to extract.", file=sys.stderr)
	except FileNotFoundError:
		print(f"ERROR: The file {input_tsv} does not exist.", file=sys.stderr)
	except pd.errors.EmptyDataError:
		print(f"ERROR: The file {input_tsv} is empty.", file=sys.stderr)
	except pd.errors.ParserError:
		print(f"ERROR: The file {input_tsv} is malformed.", file=sys.stderr)
	except KeyError:
		print(f"ERROR: The file {input_tsv} is not in the correct format. Make sure your input to --extract is a valid output from SPIDER.", file=sys.stderr)
	except UnicodeDecodeError:
		print(f"ERROR: The file {input_tsv} is not in the correct format. Make sure your input to --extract is a valid output from SPIDER.", file=sys.stderr)
	# Return false in event of errors or no sequences to extract
	return False


def get_sequence(genome_loc, contig, start, end, strand, upstream, downstream):
	"""
	Extracts the virulence factor sequence using pyfaidx.

	Arguments:
		genome_loc -- Location of genome file.
		contig -- Contig on which sequence is located.
		start -- Start position
		end -- End position
		strand -- Forward or reverse strand
		upstream -- Amount of nucleotides upstream of amplicon to include.
		downstream -- Amount of nucleotides downstream of amplicon to include.

    Returns:
		seq -- Sequence that was identified
		start_position -- Start position used when extracting sequence. This is usually 
						  the start with change by upstream/downstream nucleotides
						  depending on strand except when the modification is out of
						  bounds.
		end_position -- End position used when extracting sequence. Same as above
						regarding upstream/downstream modifications.
	"""
	genome = Fasta(genome_loc)
	contig = str(contig)
	print(contig)
	print("---")
	print(genome[contig])
	# Use contig length for validating position is in bounds
	contig_length = len(genome[contig])

	# Add upstream and downstream
	# If strand is + start = start - upstream and end = end + downtream
	# If strand is - start = start - downstream and end = end + upstream
	# Change indexing to 0 based for python by subtracting 1 off start
	if strand == "+":
		start_position = start - upstream - 1
		end_position = end + downstream
	elif strand == "-":
		start_position = start - downstream -1
		end_position = end + upstream

	# Make sure that these positions are in bounds and warn if extension was outside boundaries
	if start_position < 0: 
		start_position = 0
		if strand == "+":
			error_type = "upstream"
		else:
			error_type = "downstream"
		print(f"WARNING: {genome_loc} contig {contig} did not support full {error_type} modification. Maximum allowed extension was performed.", file=sys.stderr)
	if end_position > contig_length: 
		end_position = contig_length
		if strand == "+":
			error_type = "downstream"
		else:
			error_type = "upstream"
		print(f"WARNING: {genome_loc} contig {contig} did not support full {error_type} modification. Maximum allowed extension was performed.", file=sys.stderr)

	# Grab sequence
	seq = str(genome[contig][start_position:end_position])
	
	# Reverse complement negative strand
	if strand == "-":
		seq = reverse_complement(seq)
    
	# When returning the start position, change back to 1 based indexing
	return seq, start_position+1, end_position

def wrap_sequence(seq, width=60):
	"""
	Wraps sequence to standard FASTA width.

	Arguments:
		seq -- Sequence to wrap
		width -- Number of characters per line

	Output:
		wrapped_seq -- Wrapped sequence with newline inserted every width characters.
	"""
	# Convert Seq to string
	seq = str(seq)
	# Add newline every width characters
	wrapped_seq = '\n'.join([seq[i:i+width] for i in range(0, len(seq), width)])

	return wrapped_seq

def translate_seq(seq):
	"""
	Translates nucleotide to amino acid sequence.

	Arguments:
		seq -- Nucleotide sequence

	Output:
		aa -- Amino acid sequence
	"""
	bio_object = Seq(seq)
	return str(bio_object.translate())

